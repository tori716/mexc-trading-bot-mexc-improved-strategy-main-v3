#!/usr/bin/env python3
"""
„É¢„É°„É≥„Çø„É†Êà¶Áï• - Ë™øÊüªÂ†±ÂëäÊõ∏Ê∫ñÊã†ÂÆüË£Ö
ÊúüÂæÖÂà©ÁõäÁéá: Âπ¥Èñì25-45%ÔºàÂãùÁéá60-75%Ôºâ
„Éà„É¨„É≥„Éâ„Éï„Ç©„É≠„ÉºÂûã„ÅÆÂº∑„ÅÑÊñπÂêëÊÄßÊäïË≥áÊà¶Áï•
"""

import asyncio
import logging
import pandas as pd
import numpy as np
import sys
import os
import math
import json
from datetime import datetime, timedelta
from typing import Dict, List, Any, Optional, Tuple
from dataclasses import dataclass
from enum import Enum

# Êó¢Â≠ò„ÅÆÁµ±‰∏Ä„Ç∑„Çπ„ÉÜ„É†„ÇíÁ∂ôÊâø
from unified_system_windows import (
    WindowsDataSource, ExecutionMode, TradeSignal, TradeResult,
    WindowsUnifiedSystemFactory, AnnualBacktestSystem
)

# WindowsÁí∞Â¢ÉÁî®„ÅÆ„Ç®„É≥„Ç≥„Éº„Éá„Ç£„É≥„Ç∞Ë®≠ÂÆö
if sys.platform == "win32":
    import codecs
    sys.stdout = codecs.getwriter('utf-8')(sys.stdout.buffer)
    sys.stderr = codecs.getwriter('utf-8')(sys.stderr.buffer)

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('momentum_strategy.log', encoding='utf-8'),
        logging.StreamHandler()
    ]
)

class MomentumType(Enum):
    """„É¢„É°„É≥„Çø„É†„Çø„Ç§„Éó"""
    PRICE_MOMENTUM = "price_momentum"      # ‰æ°Ê†º„É¢„É°„É≥„Çø„É†
    TECHNICAL_MOMENTUM = "technical_momentum"  # „ÉÜ„ÇØ„Éã„Ç´„É´„É¢„É°„É≥„Çø„É†
    VOLUME_MOMENTUM = "volume_momentum"    # Âá∫Êù•È´ò„É¢„É°„É≥„Çø„É†
    CROSS_ASSET_MOMENTUM = "cross_asset_momentum"  # Ë≥áÁî£Èñì„É¢„É°„É≥„Çø„É†

@dataclass
class MomentumSignal:
    """„É¢„É°„É≥„Çø„É†„Ç∑„Ç∞„Éä„É´ÂÆöÁæ©"""
    symbol: str
    momentum_type: MomentumType
    strength: float  # „É¢„É°„É≥„Çø„É†Âº∑Â∫¶Ôºà0.0-1.0Ôºâ
    direction: str   # "BUY" or "SELL"
    confidence: float  # ‰ø°È†ºÂ∫¶Ôºà0.0-1.0Ôºâ
    timeframe: str   # ÊôÇÈñìËª∏
    entry_price: float
    target_price: float
    stop_loss_price: float
    timestamp: datetime
    duration_estimate: float  # ÊúüÂæÖ‰øùÊúâÊôÇÈñìÔºàÊôÇÈñìÔºâ

@dataclass
class MomentumPosition:
    """„É¢„É°„É≥„Çø„É†„Éù„Ç∏„Ç∑„Éß„É≥"""
    signal: MomentumSignal
    entry_time: datetime
    entry_price: float
    quantity: float
    unrealized_pnl: float = 0.0
    max_profit: float = 0.0
    max_loss: float = 0.0
    is_active: bool = True

class MomentumStrategy:
    """„É¢„É°„É≥„Çø„É†Êà¶Áï•ÔºàË™øÊüªÂ†±ÂëäÊõ∏Ê∫ñÊã†Ôºâ"""
    
    def __init__(self, config: Dict, data_source: WindowsDataSource, execution_mode: ExecutionMode):
        self.config = config
        self.data_source = data_source
        self.execution_mode = execution_mode
        self.logger = logging.getLogger(__name__)
        
        # „É¢„É°„É≥„Çø„É†ÁÆ°ÁêÜ
        self.active_positions: Dict[str, MomentumPosition] = {}
        self.trade_history = []
        self.momentum_history = {}  # „É¢„É°„É≥„Çø„É†Â±•Ê≠¥
        
        # Ë™øÊüªÂ†±ÂëäÊõ∏Ê∫ñÊã†„ÅÆË®≠ÂÆö
        self.momentum_config = {
            # „É¢„É°„É≥„Çø„É†Ê§úÂá∫Ë®≠ÂÆö
            "PRICE_MOMENTUM_PERIOD": 14,        # ‰æ°Ê†º„É¢„É°„É≥„Çø„É†ÊúüÈñì
            "MOMENTUM_THRESHOLD": 2.0,          # „É¢„É°„É≥„Çø„É†ÈñæÂÄ§ÔºàÊ®ôÊ∫ñÂÅèÂ∑ÆÂÄçÊï∞Ôºâ
            "MIN_MOMENTUM_STRENGTH": 0.6,       # ÊúÄÂ∞è„É¢„É°„É≥„Çø„É†Âº∑Â∫¶
            "TREND_CONFIRMATION_PERIOD": 5,     # „Éà„É¨„É≥„ÉâÁ¢∫Ë™çÊúüÈñì
            
            # „ÉÜ„ÇØ„Éã„Ç´„É´ÊåáÊ®ôË®≠ÂÆö
            "RSI_PERIOD": 14,                   # RSIÊúüÈñì
            "RSI_OVERSOLD": 30,                 # RSIÂ£≤„Çâ„Çå„Åô„Åé
            "RSI_OVERBOUGHT": 70,               # RSIË≤∑„Çè„Çå„Åô„Åé
            "MACD_FAST": 12,                    # MACDÈ´òÈÄüEMA
            "MACD_SLOW": 26,                    # MACD‰ΩéÈÄüEMA
            "MACD_SIGNAL": 9,                   # MACD„Ç∑„Ç∞„Éä„É´
            
            # ÁßªÂãïÂπ≥ÂùáË®≠ÂÆö
            "EMA_SHORT": 8,                     # Áü≠ÊúüEMA
            "EMA_MEDIUM": 21,                   # ‰∏≠ÊúüEMA
            "EMA_LONG": 50,                     # Èï∑ÊúüEMA
            
            # „Ç®„É≥„Éà„É™„Éº„Éª„Ç®„Ç∞„Ç∏„ÉÉ„ÉàË®≠ÂÆö
            "ENTRY_CONFIRMATION_BARS": 2,       # „Ç®„É≥„Éà„É™„ÉºÁ¢∫Ë™ç„Éê„ÉºÊï∞
            "TAKE_PROFIT_MULTIPLIER": 2.5,      # Âà©Á¢∫ÂÄçÊï∞ÔºàATRÂü∫Ê∫ñÔºâ
            "STOP_LOSS_MULTIPLIER": 1.5,        # ÊêçÂàá„ÇäÂÄçÊï∞ÔºàATRÂü∫Ê∫ñÔºâ
            "TRAILING_STOP_ACTIVATION": 1.5,    # „Éà„É¨„Éº„É™„É≥„Ç∞„Çπ„Éà„ÉÉ„ÉóÁô∫ÂãïÂà©Áõä
            "TRAILING_STOP_DISTANCE": 1.0,      # „Éà„É¨„Éº„É™„É≥„Ç∞„Çπ„Éà„ÉÉ„ÉóË∑ùÈõ¢
            
            # „Éù„Ç∏„Ç∑„Éß„É≥ÁÆ°ÁêÜ
            "MAX_POSITIONS": 6,                 # ÊúÄÂ§ß„Éù„Ç∏„Ç∑„Éß„É≥Êï∞
            "POSITION_SIZE_PCT": 15.0,          # „Éù„Ç∏„Ç∑„Éß„É≥„Çµ„Ç§„Ç∫ÔºàË≥áÈáë„ÅÆ15%Ôºâ
            "MIN_VOLUME_RATIO": 1.2,            # ÊúÄÂ∞èÂá∫Êù•È´òÂÄçÁéá
            "MAX_CORRELATION": 0.7,             # ÊúÄÂ§ßÁõ∏Èñ¢‰øÇÊï∞
            
            # ÊôÇÈñìÁÆ°ÁêÜ
            "MAX_HOLD_HOURS": 72,               # ÊúÄÂ§ß‰øùÊúâÊôÇÈñìÔºà3Êó•Ôºâ
            "MIN_HOLD_MINUTES": 30,             # ÊúÄÂ∞è‰øùÊúâÊôÇÈñìÔºà30ÂàÜÔºâ
            "REBALANCE_INTERVAL_HOURS": 4,      # „É™„Éê„É©„É≥„ÇπÈñìÈöî
        }
    
    async def analyze_momentum_signals(self, symbols: List[str]) -> List[MomentumSignal]:
        """„É¢„É°„É≥„Çø„É†„Ç∑„Ç∞„Éä„É´ÂàÜÊûê"""
        
        signals = []
        current_time = self.data_source.get_current_time()
        
        for symbol in symbols:
            try:
                # Ë§áÊï∞ÊôÇÈñìËª∏„ÅÆ„Éá„Éº„ÇøÂèñÂæó
                ohlcv_1h = await self.data_source.get_ohlcv(symbol, "60m", 100)
                ohlcv_4h = await self.data_source.get_ohlcv(symbol, "240m", 50)
                
                if not ohlcv_1h or not ohlcv_4h:
                    continue
                
                # ‰æ°Ê†º„É¢„É°„É≥„Çø„É†ÂàÜÊûê
                price_signals = self._analyze_price_momentum(symbol, ohlcv_1h, ohlcv_4h)
                signals.extend(price_signals)
                
                # „ÉÜ„ÇØ„Éã„Ç´„É´„É¢„É°„É≥„Çø„É†ÂàÜÊûê
                technical_signals = self._analyze_technical_momentum(symbol, ohlcv_1h)
                signals.extend(technical_signals)
                
                # Âá∫Êù•È´ò„É¢„É°„É≥„Çø„É†ÂàÜÊûê
                volume_signals = self._analyze_volume_momentum(symbol, ohlcv_1h)
                signals.extend(volume_signals)
                
            except Exception as e:
                self.logger.warning(f"„É¢„É°„É≥„Çø„É†ÂàÜÊûê„Ç®„É©„Éº {symbol}: {e}")
                continue
        
        # „Ç∑„Ç∞„Éä„É´„Éï„Ç£„É´„Çø„É™„É≥„Ç∞„Éª„É©„É≥„Ç≠„É≥„Ç∞
        filtered_signals = self._filter_and_rank_signals(signals)
        
        if filtered_signals:
            self.logger.info(f"üöÄ „É¢„É°„É≥„Çø„É†„Ç∑„Ç∞„Éä„É´Ê§úÂá∫: {len(filtered_signals)}‰ª∂")
            for i, signal in enumerate(filtered_signals[:3]):
                self.logger.info(f"   {i+1}. {signal.symbol} {signal.direction} "
                               f"Âº∑Â∫¶{signal.strength:.2f} ‰ø°È†ºÂ∫¶{signal.confidence:.2f}")
        
        return filtered_signals
    
    def _analyze_price_momentum(self, symbol: str, ohlcv_1h: List, ohlcv_4h: List) -> List[MomentumSignal]:
        """‰æ°Ê†º„É¢„É°„É≥„Çø„É†ÂàÜÊûê"""
        
        signals = []
        current_time = self.data_source.get_current_time()
        
        try:
            df_1h = pd.DataFrame(ohlcv_1h)
            df_4h = pd.DataFrame(ohlcv_4h)
            
            if len(df_1h) < 50 or len(df_4h) < 25:
                return signals
            
            # ‰æ°Ê†ºÂ§âÂåñÁéáË®àÁÆóÔºàË§áÊï∞ÊúüÈñìÔºâ
            periods = [5, 10, 14, 20]
            momentum_scores = []
            
            for period in periods:
                if len(df_1h) > period:
                    price_change = (df_1h['close'].iloc[-1] - df_1h['close'].iloc[-period-1]) / df_1h['close'].iloc[-period-1] * 100
                    momentum_scores.append(abs(price_change))
            
            if not momentum_scores:
                return signals
            
            # „É¢„É°„É≥„Çø„É†Âº∑Â∫¶Ë®àÁÆó
            avg_momentum = sum(momentum_scores) / len(momentum_scores)
            momentum_strength = min(avg_momentum / 10.0, 1.0)  # 10%Â§âÂåñ„ÅßÂº∑Â∫¶1.0
            
            # „Éà„É¨„É≥„ÉâÊñπÂêëÊÄßÂà§ÂÆö
            current_price = df_1h['close'].iloc[-1]
            ema_short = df_1h['close'].ewm(span=self.momentum_config["EMA_SHORT"]).mean().iloc[-1]
            ema_medium = df_1h['close'].ewm(span=self.momentum_config["EMA_MEDIUM"]).mean().iloc[-1]
            ema_long = df_1h['close'].ewm(span=self.momentum_config["EMA_LONG"]).mean().iloc[-1]
            
            # EMA„ÅÆ‰∏¶„Å≥È†Ü„Åß„Éà„É¨„É≥„ÉâÂà§ÂÆö
            if ema_short > ema_medium > ema_long and current_price > ema_short:
                direction = "BUY"
                confidence = 0.8
            elif ema_short < ema_medium < ema_long and current_price < ema_short:
                direction = "SELL"
                confidence = 0.8
            else:
                direction = "BUY" if current_price > ema_medium else "SELL"
                confidence = 0.6
            
            # „É¢„É°„É≥„Çø„É†ÈñæÂÄ§„ÉÅ„Çß„ÉÉ„ÇØ
            if momentum_strength >= self.momentum_config["MIN_MOMENTUM_STRENGTH"]:
                
                # ATRË®àÁÆóÔºà„É™„Çπ„ÇØÁÆ°ÁêÜÁî®Ôºâ
                atr = self._calculate_atr(df_1h, 14)
                
                # „Çø„Éº„Ç≤„ÉÉ„Éà„Éª„Çπ„Éà„ÉÉ„Éó„É≠„Çπ‰æ°Ê†ºË®àÁÆó
                if direction == "BUY":
                    target_price = current_price * (1 + (atr * self.momentum_config["TAKE_PROFIT_MULTIPLIER"] / current_price))
                    stop_loss_price = current_price * (1 - (atr * self.momentum_config["STOP_LOSS_MULTIPLIER"] / current_price))
                else:
                    target_price = current_price * (1 - (atr * self.momentum_config["TAKE_PROFIT_MULTIPLIER"] / current_price))
                    stop_loss_price = current_price * (1 + (atr * self.momentum_config["STOP_LOSS_MULTIPLIER"] / current_price))
                
                signal = MomentumSignal(
                    symbol=symbol,
                    momentum_type=MomentumType.PRICE_MOMENTUM,
                    strength=momentum_strength,
                    direction=direction,
                    confidence=confidence,
                    timeframe="1h",
                    entry_price=current_price,
                    target_price=target_price,
                    stop_loss_price=stop_loss_price,
                    timestamp=current_time,
                    duration_estimate=24  # 24ÊôÇÈñìÁ®ãÂ∫¶„ÅÆ‰øùÊúâÊúüÂæÖ
                )
                signals.append(signal)
        
        except Exception as e:
            self.logger.warning(f"‰æ°Ê†º„É¢„É°„É≥„Çø„É†ÂàÜÊûê„Ç®„É©„Éº {symbol}: {e}")
        
        return signals
    
    def _analyze_technical_momentum(self, symbol: str, ohlcv_data: List) -> List[MomentumSignal]:
        """„ÉÜ„ÇØ„Éã„Ç´„É´„É¢„É°„É≥„Çø„É†ÂàÜÊûê"""
        
        signals = []
        current_time = self.data_source.get_current_time()
        
        try:
            df = pd.DataFrame(ohlcv_data)
            if len(df) < 50:
                return signals
            
            # RSIË®àÁÆó
            rsi = self._calculate_rsi(df['close'], self.momentum_config["RSI_PERIOD"])
            current_rsi = rsi.iloc[-1]
            
            # MACDË®àÁÆó
            macd_line, macd_signal, macd_histogram = self._calculate_macd(
                df['close'], 
                self.momentum_config["MACD_FAST"], 
                self.momentum_config["MACD_SLOW"], 
                self.momentum_config["MACD_SIGNAL"]
            )
            
            current_macd = macd_line.iloc[-1]
            current_signal = macd_signal.iloc[-1]
            current_histogram = macd_histogram.iloc[-1]
            
            # „Éú„É™„É≥„Ç∏„É£„Éº„Éê„É≥„ÉâË®àÁÆó
            bb_upper, bb_middle, bb_lower = self._calculate_bollinger_bands(df['close'], 20, 2)
            current_price = df['close'].iloc[-1]
            
            # „ÉÜ„ÇØ„Éã„Ç´„É´Êù°‰ª∂Âà§ÂÆö
            technical_strength = 0.0
            direction = None
            confidence = 0.0
            
            # MACDÂº∑Ê∞ó„Ç∑„Ç∞„Éä„É´
            if current_macd > current_signal and macd_histogram.iloc[-1] > macd_histogram.iloc[-2]:
                technical_strength += 0.3
                direction = "BUY"
                confidence += 0.25
            
            # MACDÂº±Ê∞ó„Ç∑„Ç∞„Éä„É´
            elif current_macd < current_signal and macd_histogram.iloc[-1] < macd_histogram.iloc[-2]:
                technical_strength += 0.3
                direction = "SELL"
                confidence += 0.25
            
            # RSI„É¢„É°„É≥„Çø„É†
            if 30 < current_rsi < 70:  # ‰∏≠Á´ãÂüü„Åß„ÅÆ„É¢„É°„É≥„Çø„É†
                if current_rsi > 55:
                    technical_strength += 0.2
                    if direction != "SELL":
                        direction = "BUY"
                    confidence += 0.15
                elif current_rsi < 45:
                    technical_strength += 0.2
                    if direction != "BUY":
                        direction = "SELL"
                    confidence += 0.15
            
            # „Éú„É™„É≥„Ç∏„É£„Éº„Éê„É≥„Éâ„Éñ„É¨„Ç§„ÇØ„Ç¢„Ç¶„Éà
            if current_price > bb_upper.iloc[-1]:
                technical_strength += 0.3
                direction = "BUY"
                confidence += 0.3
            elif current_price < bb_lower.iloc[-1]:
                technical_strength += 0.3
                direction = "SELL"
                confidence += 0.3
            
            # ÁßªÂãïÂπ≥Âùá„ÇØ„É≠„Çπ
            ema_8 = df['close'].ewm(span=8).mean()
            ema_21 = df['close'].ewm(span=21).mean()
            
            if ema_8.iloc[-1] > ema_21.iloc[-1] and ema_8.iloc[-2] <= ema_21.iloc[-2]:
                technical_strength += 0.2
                direction = "BUY"
                confidence += 0.2
            elif ema_8.iloc[-1] < ema_21.iloc[-1] and ema_8.iloc[-2] >= ema_21.iloc[-2]:
                technical_strength += 0.2
                direction = "SELL"
                confidence += 0.2
            
            # „Ç∑„Ç∞„Éä„É´ÁîüÊàê
            if technical_strength >= 0.5 and direction and confidence >= 0.4:
                
                # ATRË®àÁÆó
                atr = self._calculate_atr(df, 14)
                
                # „Çø„Éº„Ç≤„ÉÉ„Éà„Éª„Çπ„Éà„ÉÉ„Éó„É≠„Çπ‰æ°Ê†ºË®àÁÆó
                if direction == "BUY":
                    target_price = current_price * (1 + (atr * 2.0 / current_price))
                    stop_loss_price = current_price * (1 - (atr * 1.2 / current_price))
                else:
                    target_price = current_price * (1 - (atr * 2.0 / current_price))
                    stop_loss_price = current_price * (1 + (atr * 1.2 / current_price))
                
                signal = MomentumSignal(
                    symbol=symbol,
                    momentum_type=MomentumType.TECHNICAL_MOMENTUM,
                    strength=technical_strength,
                    direction=direction,
                    confidence=confidence,
                    timeframe="1h",
                    entry_price=current_price,
                    target_price=target_price,
                    stop_loss_price=stop_loss_price,
                    timestamp=current_time,
                    duration_estimate=12  # 12ÊôÇÈñìÁ®ãÂ∫¶„ÅÆ‰øùÊúâÊúüÂæÖ
                )
                signals.append(signal)
        
        except Exception as e:
            self.logger.warning(f"„ÉÜ„ÇØ„Éã„Ç´„É´„É¢„É°„É≥„Çø„É†ÂàÜÊûê„Ç®„É©„Éº {symbol}: {e}")
        
        return signals
    
    def _analyze_volume_momentum(self, symbol: str, ohlcv_data: List) -> List[MomentumSignal]:
        """Âá∫Êù•È´ò„É¢„É°„É≥„Çø„É†ÂàÜÊûê"""
        
        signals = []
        current_time = self.data_source.get_current_time()
        
        try:
            df = pd.DataFrame(ohlcv_data)
            if len(df) < 30:
                return signals
            
            # Âá∫Êù•È´òÂàÜÊûê
            current_volume = df['volume'].iloc[-1]
            avg_volume_20 = df['volume'].rolling(window=20).mean().iloc[-1]
            volume_ratio = current_volume / avg_volume_20 if avg_volume_20 > 0 else 1
            
            # Âá∫Êù•È´òÂä†ÈáçÂπ≥Âùá‰æ°Ê†ºÔºàVWAPÔºâ
            vwap = (df['volume'] * (df['high'] + df['low'] + df['close']) / 3).cumsum() / df['volume'].cumsum()
            current_price = df['close'].iloc[-1]
            current_vwap = vwap.iloc[-1]
            
            # ‰æ°Ê†º„ÉªÂá∫Êù•È´òÁõ∏Èñ¢
            price_changes = df['close'].pct_change().dropna()
            volume_changes = df['volume'].pct_change().dropna()
            
            if len(price_changes) >= 10 and len(volume_changes) >= 10:
                correlation = price_changes.tail(10).corr(volume_changes.tail(10))
                
                # Âá∫Êù•È´ò„É¢„É°„É≥„Çø„É†Êù°‰ª∂
                volume_strength = 0.0
                direction = None
                confidence = 0.0
                
                # Â§ßÈáèÂá∫Êù•È´ò„Éñ„É¨„Ç§„ÇØ„Ç¢„Ç¶„Éà
                if volume_ratio > self.momentum_config["MIN_VOLUME_RATIO"]:
                    volume_strength += 0.4
                    confidence += 0.3
                    
                    # VWAPÂü∫Ê∫ñÊñπÂêëÂà§ÂÆö
                    if current_price > current_vwap * 1.002:  # 0.2%‰ª•‰∏ä‰∏ä
                        direction = "BUY"
                        confidence += 0.2
                    elif current_price < current_vwap * 0.998:  # 0.2%‰ª•‰∏ä‰∏ã
                        direction = "SELL"
                        confidence += 0.2
                
                # ‰æ°Ê†º„ÉªÂá∫Êù•È´ò„ÅÆÊ≠£Áõ∏Èñ¢Ôºà„Éà„É¨„É≥„ÉâÁ∂ôÁ∂öÔºâ
                if not pd.isna(correlation) and abs(correlation) > 0.5:
                    volume_strength += 0.3
                    confidence += 0.2
                    
                    if correlation > 0 and current_price > current_vwap:
                        direction = "BUY"
                    elif correlation > 0 and current_price < current_vwap:
                        direction = "SELL"
                
                # Á¥ØÁ©çÂá∫Êù•È´òÊåáÊï∞ÔºàOBVÈ¢®Ôºâ
                obv = ((df['close'] - df['close'].shift(1)) / df['close'].shift(1) * df['volume']).cumsum()
                obv_sma = obv.rolling(window=10).mean()
                
                if obv.iloc[-1] > obv_sma.iloc[-1] and obv.iloc[-2] <= obv_sma.iloc[-2]:
                    volume_strength += 0.3
                    direction = "BUY"
                    confidence += 0.25
                elif obv.iloc[-1] < obv_sma.iloc[-1] and obv.iloc[-2] >= obv_sma.iloc[-2]:
                    volume_strength += 0.3
                    direction = "SELL"
                    confidence += 0.25
                
                # „Ç∑„Ç∞„Éä„É´ÁîüÊàê
                if volume_strength >= 0.6 and direction and confidence >= 0.5:
                    
                    # ATRË®àÁÆó
                    atr = self._calculate_atr(df, 14)
                    
                    # „Çø„Éº„Ç≤„ÉÉ„Éà„Éª„Çπ„Éà„ÉÉ„Éó„É≠„Çπ‰æ°Ê†ºË®àÁÆó
                    if direction == "BUY":
                        target_price = current_price * (1 + (atr * 2.2 / current_price))
                        stop_loss_price = current_price * (1 - (atr * 1.3 / current_price))
                    else:
                        target_price = current_price * (1 - (atr * 2.2 / current_price))
                        stop_loss_price = current_price * (1 + (atr * 1.3 / current_price))
                    
                    signal = MomentumSignal(
                        symbol=symbol,
                        momentum_type=MomentumType.VOLUME_MOMENTUM,
                        strength=volume_strength,
                        direction=direction,
                        confidence=confidence,
                        timeframe="1h",
                        entry_price=current_price,
                        target_price=target_price,
                        stop_loss_price=stop_loss_price,
                        timestamp=current_time,
                        duration_estimate=8  # 8ÊôÇÈñìÁ®ãÂ∫¶„ÅÆ‰øùÊúâÊúüÂæÖ
                    )
                    signals.append(signal)
        
        except Exception as e:
            self.logger.warning(f"Âá∫Êù•È´ò„É¢„É°„É≥„Çø„É†ÂàÜÊûê„Ç®„É©„Éº {symbol}: {e}")
        
        return signals
    
    def _filter_and_rank_signals(self, signals: List[MomentumSignal]) -> List[MomentumSignal]:
        """„Ç∑„Ç∞„Éä„É´„Éï„Ç£„É´„Çø„É™„É≥„Ç∞„Éª„É©„É≥„Ç≠„É≥„Ç∞"""
        
        # „Éï„Ç£„É´„Çø„É™„É≥„Ç∞
        filtered = []
        for signal in signals:
            # ÊúÄÂ∞èÂº∑Â∫¶„ÉÅ„Çß„ÉÉ„ÇØ
            if signal.strength < self.momentum_config["MIN_MOMENTUM_STRENGTH"]:
                continue
            
            # ÊúÄÂ∞è‰ø°È†ºÂ∫¶„ÉÅ„Çß„ÉÉ„ÇØ
            if signal.confidence < 0.4:
                continue
            
            # „É™„Çπ„ÇØ„É™„ÉØ„Éº„ÉâÊØî„ÉÅ„Çß„ÉÉ„ÇØ
            if signal.direction == "BUY":
                risk = signal.entry_price - signal.stop_loss_price
                reward = signal.target_price - signal.entry_price
            else:
                risk = signal.stop_loss_price - signal.entry_price
                reward = signal.entry_price - signal.target_price
            
            if risk <= 0 or reward <= 0 or (reward / risk) < 1.2:
                continue
            
            filtered.append(signal)
        
        # „É©„É≥„Ç≠„É≥„Ç∞ÔºàÂº∑Â∫¶ √ó ‰ø°È†ºÂ∫¶„Åß„ÇΩ„Éº„ÉàÔºâ
        filtered.sort(key=lambda x: x.strength * x.confidence, reverse=True)
        
        return filtered
    
    def _calculate_rsi(self, prices: pd.Series, period: int) -> pd.Series:
        """RSIË®àÁÆó"""
        delta = prices.diff()
        gain = (delta.where(delta > 0, 0)).rolling(window=period).mean()
        loss = (-delta.where(delta < 0, 0)).rolling(window=period).mean()
        rs = gain / loss
        rsi = 100 - (100 / (1 + rs))
        return rsi
    
    def _calculate_macd(self, prices: pd.Series, fast: int, slow: int, signal: int) -> Tuple[pd.Series, pd.Series, pd.Series]:
        """MACDË®àÁÆó"""
        ema_fast = prices.ewm(span=fast).mean()
        ema_slow = prices.ewm(span=slow).mean()
        macd_line = ema_fast - ema_slow
        macd_signal = macd_line.ewm(span=signal).mean()
        macd_histogram = macd_line - macd_signal
        return macd_line, macd_signal, macd_histogram
    
    def _calculate_bollinger_bands(self, prices: pd.Series, period: int, std_dev: float) -> Tuple[pd.Series, pd.Series, pd.Series]:
        """„Éú„É™„É≥„Ç∏„É£„Éº„Éê„É≥„ÉâË®àÁÆó"""
        sma = prices.rolling(window=period).mean()
        std = prices.rolling(window=period).std()
        upper_band = sma + (std * std_dev)
        lower_band = sma - (std * std_dev)
        return upper_band, sma, lower_band
    
    def _calculate_atr(self, df: pd.DataFrame, period: int) -> float:
        """ATRË®àÁÆó"""
        high_low = df['high'] - df['low']
        high_close_prev = abs(df['high'] - df['close'].shift(1))
        low_close_prev = abs(df['low'] - df['close'].shift(1))
        true_range = pd.concat([high_low, high_close_prev, low_close_prev], axis=1).max(axis=1)
        atr = true_range.rolling(window=period).mean().iloc[-1]
        return atr if not pd.isna(atr) else df['close'].iloc[-1] * 0.02  # 2%„Çí„Éá„Éï„Ç©„É´„Éà
    
    async def execute_momentum_trade(self, signal: MomentumSignal) -> bool:
        """„É¢„É°„É≥„Çø„É†ÂèñÂºïÂÆüË°å"""
        
        try:
            current_price = await self.data_source.get_current_price(signal.symbol)
            current_time = self.data_source.get_current_time()
            
            # „Éù„Ç∏„Ç∑„Éß„É≥„Çµ„Ç§„Ç∫Ë®àÁÆó
            risk_per_trade = 1000 * (self.momentum_config["POSITION_SIZE_PCT"] / 100)  # 15%
            if signal.direction == "BUY":
                risk_per_share = signal.entry_price - signal.stop_loss_price
            else:
                risk_per_share = signal.stop_loss_price - signal.entry_price
            
            if risk_per_share <= 0:
                return False
            
            quantity = risk_per_trade / risk_per_share
            
            # ÊúÄÂ∞èÂèñÂºïÈáè„ÉÅ„Çß„ÉÉ„ÇØ
            if quantity * current_price < 50:  # ÊúÄÂ∞è$50
                quantity = 50 / current_price
            
            # „Ç®„É≥„Éà„É™„ÉºÂÆüË°å
            order_result = await self.data_source.place_order(
                symbol=signal.symbol,
                side=signal.direction,
                order_type="MARKET",
                quantity=quantity
            )
            
            if order_result.get("status") == "FILLED":
                # „Éù„Ç∏„Ç∑„Éß„É≥Ë®òÈå≤
                position = MomentumPosition(
                    signal=signal,
                    entry_time=current_time,
                    entry_price=current_price,
                    quantity=quantity
                )
                
                self.active_positions[signal.symbol] = position
                
                self.logger.info(f"üöÄ „É¢„É°„É≥„Çø„É†ÂèñÂºïÂÆüË°å: {signal.momentum_type.value}")
                self.logger.info(f"   {signal.symbol} {signal.direction} ${current_price:.4f}")
                self.logger.info(f"   Âº∑Â∫¶{signal.strength:.2f} ‰ø°È†ºÂ∫¶{signal.confidence:.2f}")
                
                return True
            else:
                self.logger.error(f"‚ùå „É¢„É°„É≥„Çø„É†ÂèñÂºïÂ§±Êïó: {signal.symbol}")
                return False
                
        except Exception as e:
            self.logger.error(f"‚ùå „É¢„É°„É≥„Çø„É†ÂèñÂºïÂÆüË°å„Ç®„É©„Éº: {str(e)}")
            return False
    
    async def manage_momentum_positions(self) -> List[TradeResult]:
        """„É¢„É°„É≥„Çø„É†„Éù„Ç∏„Ç∑„Éß„É≥ÁÆ°ÁêÜ"""
        
        trades = []
        current_time = self.data_source.get_current_time()
        positions_to_close = []
        
        for symbol, position in self.active_positions.items():
            if not position.is_active:
                continue
            
            try:
                current_price = await self.data_source.get_current_price(symbol)
                signal = position.signal
                
                # ÊêçÁõäË®àÁÆó
                if signal.direction == "BUY":
                    unrealized_pnl = (current_price - position.entry_price) * position.quantity
                    profit_pct = (current_price - position.entry_price) / position.entry_price * 100
                else:
                    unrealized_pnl = (position.entry_price - current_price) * position.quantity
                    profit_pct = (position.entry_price - current_price) / position.entry_price * 100
                
                position.unrealized_pnl = unrealized_pnl
                position.max_profit = max(position.max_profit, unrealized_pnl)
                position.max_loss = min(position.max_loss, unrealized_pnl)
                
                # Âà©Á¢∫Êù°‰ª∂„ÉÅ„Çß„ÉÉ„ÇØ
                if signal.direction == "BUY" and current_price >= signal.target_price:
                    trade = await self._close_momentum_position(position, current_price, current_time, "Âà©Á¢∫ÈÅîÊàê")
                    if trade:
                        trades.append(trade)
                        positions_to_close.append(symbol)
                elif signal.direction == "SELL" and current_price <= signal.target_price:
                    trade = await self._close_momentum_position(position, current_price, current_time, "Âà©Á¢∫ÈÅîÊàê")
                    if trade:
                        trades.append(trade)
                        positions_to_close.append(symbol)
                
                # „Çπ„Éà„ÉÉ„Éó„É≠„ÇπÊù°‰ª∂„ÉÅ„Çß„ÉÉ„ÇØ
                elif signal.direction == "BUY" and current_price <= signal.stop_loss_price:
                    trade = await self._close_momentum_position(position, current_price, current_time, "„Çπ„Éà„ÉÉ„Éó„É≠„Çπ")
                    if trade:
                        trades.append(trade)
                        positions_to_close.append(symbol)
                elif signal.direction == "SELL" and current_price >= signal.stop_loss_price:
                    trade = await self._close_momentum_position(position, current_price, current_time, "„Çπ„Éà„ÉÉ„Éó„É≠„Çπ")
                    if trade:
                        trades.append(trade)
                        positions_to_close.append(symbol)
                
                # „Éà„É¨„Éº„É™„É≥„Ç∞„Çπ„Éà„ÉÉ„Éó
                elif position.max_profit > 0 and position.max_profit >= position.entry_price * position.quantity * 0.05:  # 5%Âà©Áõä„Åß„Éà„É¨„Éº„É™„É≥„Ç∞ÈñãÂßã
                    trailing_stop_price = None
                    
                    if signal.direction == "BUY":
                        trailing_stop_price = current_price * (1 - self.momentum_config["TRAILING_STOP_DISTANCE"] / 100)
                        if current_price <= trailing_stop_price:
                            trade = await self._close_momentum_position(position, current_price, current_time, "„Éà„É¨„Éº„É™„É≥„Ç∞„Çπ„Éà„ÉÉ„Éó")
                    else:
                        trailing_stop_price = current_price * (1 + self.momentum_config["TRAILING_STOP_DISTANCE"] / 100)
                        if current_price >= trailing_stop_price:
                            trade = await self._close_momentum_position(position, current_price, current_time, "„Éà„É¨„Éº„É™„É≥„Ç∞„Çπ„Éà„ÉÉ„Éó")
                    
                    if trade:
                        trades.append(trade)
                        positions_to_close.append(symbol)
                
                # ÊôÇÈñìÂàá„Çå„ÉÅ„Çß„ÉÉ„ÇØ
                hold_hours = (current_time - position.entry_time).total_seconds() / 3600
                if hold_hours >= self.momentum_config["MAX_HOLD_HOURS"]:
                    trade = await self._close_momentum_position(position, current_price, current_time, "ÊôÇÈñìÂàá„Çå")
                    if trade:
                        trades.append(trade)
                        positions_to_close.append(symbol)
                
            except Exception as e:
                self.logger.warning(f"„Éù„Ç∏„Ç∑„Éß„É≥ÁÆ°ÁêÜ„Ç®„É©„Éº {symbol}: {e}")
                continue
        
        # „Éù„Ç∏„Ç∑„Éß„É≥„ÇØ„É≠„Éº„Ç∫
        for symbol in positions_to_close:
            del self.active_positions[symbol]
        
        return trades
    
    async def _close_momentum_position(self, position: MomentumPosition, current_price: float,
                                     current_time: datetime, exit_reason: str) -> Optional[TradeResult]:
        """„É¢„É°„É≥„Çø„É†„Éù„Ç∏„Ç∑„Éß„É≥Ê±∫Ê∏à"""
        
        try:
            signal = position.signal
            
            # ÂèçÂØæÂ£≤Ë≤∑ÂÆüË°å
            side = "SELL" if signal.direction == "BUY" else "BUY"
            order_result = await self.data_source.place_order(
                symbol=signal.symbol,
                side=side,
                order_type="MARKET",
                quantity=position.quantity
            )
            
            if order_result.get("status") == "FILLED":
                # ÊêçÁõäË®àÁÆó
                if signal.direction == "BUY":
                    profit_loss = (current_price - position.entry_price) * position.quantity
                else:
                    profit_loss = (position.entry_price - current_price) * position.quantity
                
                profit_pct = (profit_loss / (position.entry_price * position.quantity)) * 100
                hold_hours = (current_time - position.entry_time).total_seconds() / 3600
                
                trade = TradeResult(
                    symbol=signal.symbol,
                    entry_time=position.entry_time,
                    exit_time=current_time,
                    side=signal.direction,
                    entry_price=position.entry_price,
                    exit_price=current_price,
                    quantity=position.quantity,
                    profit_loss=profit_loss,
                    profit_pct=profit_pct,
                    hold_hours=hold_hours,
                    exit_reason=f"„É¢„É°„É≥„Çø„É†_{exit_reason}"
                )
                
                self.trade_history.append(trade)
                
                self.logger.info(f"üöÄ „É¢„É°„É≥„Çø„É†Ê±∫Ê∏à: {signal.symbol} {exit_reason}")
                self.logger.info(f"   „Ç®„É≥„Éà„É™„Éº: ${position.entry_price:.4f} ‚Üí Ê±∫Ê∏à: ${current_price:.4f}")
                self.logger.info(f"   Âà©Áõä: ${profit_loss:.2f} ({profit_pct:+.2f}%) ‰øùÊúâ{hold_hours:.1f}ÊôÇÈñì")
                
                return trade
            else:
                self.logger.error(f"‚ùå „É¢„É°„É≥„Çø„É†Ê±∫Ê∏àÂ§±Êïó: {signal.symbol}")
                return None
                
        except Exception as e:
            self.logger.error(f"„É¢„É°„É≥„Çø„É†Ê±∫Ê∏à„Ç®„É©„Éº: {str(e)}")
            return None

class MomentumBacktestSystem(AnnualBacktestSystem):
    """„É¢„É°„É≥„Çø„É†„Éê„ÉÉ„ÇØ„ÉÜ„Çπ„Éà„Ç∑„Çπ„ÉÜ„É†"""
    
    def __init__(self, config: Dict, historical_data: Dict[str, pd.DataFrame], 
                 symbols: List[str], start_date: datetime, end_date: datetime):
        super().__init__(config, historical_data, symbols, start_date, end_date)
        
        self.momentum_strategy = MomentumStrategy(
            config, WindowsDataSource(ExecutionMode.BACKTEST, historical_data), ExecutionMode.BACKTEST
        )
        
        # „É¢„É°„É≥„Çø„É†Â∞ÇÁî®Ë®≠ÂÆö
        self.enhanced_config.update({
            "STRATEGY_NAME": "„É¢„É°„É≥„Çø„É†Êà¶Áï•",
            "EXPECTED_ANNUAL_RETURN": 35.0,  # 25-45%„ÅÆ‰∏≠Â§ÆÂÄ§
            "MAX_POSITIONS": 6,              # ÊúÄÂ§ß„Éù„Ç∏„Ç∑„Éß„É≥Êï∞
            "REBALANCE_INTERVAL": 4,         # 4ÊôÇÈñì„Åî„Å®„ÉÅ„Çß„ÉÉ„ÇØ
        })
    
    async def _execute_annual_backtest(self):
        """„É¢„É°„É≥„Çø„É†Âπ¥Èñì„Éê„ÉÉ„ÇØ„ÉÜ„Çπ„ÉàÂÆüË°å"""
        
        capital = self.enhanced_config["INITIAL_CAPITAL"]
        
        # ÊôÇÈñì„Çπ„ÉÜ„ÉÉ„ÉóÔºà4ÊôÇÈñì„Åî„Å®Ôºâ
        timestamps = list(self.historical_data[self.symbols[0]].index[::4])
        
        for i, timestamp in enumerate(timestamps):
            try:
                # „Éá„Éº„Çø„ÇΩ„Éº„ÇπÊôÇÂàªË®≠ÂÆö
                self.momentum_strategy.data_source.set_current_time(timestamp)
                current_portfolio_value = capital
                
                # Êó¢Â≠ò„É¢„É°„É≥„Çø„É†„Éù„Ç∏„Ç∑„Éß„É≥ÁÆ°ÁêÜ
                trades = await self.momentum_strategy.manage_momentum_positions()
                for trade in trades:
                    capital += trade.profit_loss + (trade.entry_price * trade.quantity)
                    self.trades.append(trade)
                    current_portfolio_value += trade.profit_loss
                
                # Êñ∞Ë¶è„É¢„É°„É≥„Çø„É†„Ç∑„Ç∞„Éä„É´Ê§úÁ¥¢
                active_positions = len(self.momentum_strategy.active_positions)
                if active_positions < self.enhanced_config["MAX_POSITIONS"]:
                    
                    signals = await self.momentum_strategy.analyze_momentum_signals(self.symbols)
                    
                    for signal in signals[:3]:  # TOP3ÂÆüË°å
                        if active_positions >= self.enhanced_config["MAX_POSITIONS"]:
                            break
                        
                        # ÈáçË§á„ÉÅ„Çß„ÉÉ„ÇØ
                        if signal.symbol not in self.momentum_strategy.active_positions:
                            required_capital = signal.entry_price * 100  # ÊúÄÂ∞è$100
                            
                            if capital > required_capital:
                                success = await self.momentum_strategy.execute_momentum_trade(signal)
                                if success:
                                    capital -= required_capital
                                    active_positions += 1
                                    self.logger.info(f"üöÄ {signal.symbol} „É¢„É°„É≥„Çø„É†ÈñãÂßã: {signal.momentum_type.value}")
                
                # „Éù„Éº„Éà„Éï„Ç©„É™„Ç™‰æ°ÂÄ§Ë®àÁÆó
                momentum_investment = sum([
                    pos.entry_price * pos.quantity for pos in self.momentum_strategy.active_positions.values()
                ])
                portfolio_value = capital + momentum_investment
                
                # Êó•Ê¨°Ë®òÈå≤
                if i % 6 == 0:  # 24ÊôÇÈñì„Åî„Å®
                    self.daily_portfolio.append({
                        'timestamp': timestamp,
                        'portfolio_value': portfolio_value,
                        'cash': capital,
                        'positions': len(self.momentum_strategy.active_positions),
                        'return_pct': ((portfolio_value - self.enhanced_config["INITIAL_CAPITAL"]) / 
                                     self.enhanced_config["INITIAL_CAPITAL"]) * 100
                    })
                
                # ÈÄ≤ÊçóË°®Á§∫
                if i % 168 == 0:  # ÈÄ±Ê¨°
                    progress = (i / len(timestamps)) * 100
                    weeks = i // 42
                    active_positions = len(self.momentum_strategy.active_positions)
                    self.logger.info(f"  ÈÄ≤Êçó: {progress:.1f}% ({weeks}ÈÄ±ÁµåÈÅé) „Ç¢„ÇØ„ÉÜ„Ç£„Éñ„Éù„Ç∏„Ç∑„Éß„É≥:{active_positions}")
                
            except Exception as e:
                self.logger.warning(f"„Çø„Ç§„É†„Çπ„Çø„É≥„Éó {timestamp} „Åß„Ç®„É©„Éº: {str(e)}")
                continue

# „É°„Ç§„É≥ÂÆüË°åÈñ¢Êï∞
async def run_momentum_backtest():
    """„É¢„É°„É≥„Çø„É†Êà¶Áï•„Éê„ÉÉ„ÇØ„ÉÜ„Çπ„ÉàÂÆüË°å"""
    
    logger = logging.getLogger(__name__)
    logger.info("üöÄ „É¢„É°„É≥„Çø„É†Êà¶Áï• 1Âπ¥Èñì„Éê„ÉÉ„ÇØ„ÉÜ„Çπ„ÉàÈñãÂßã")
    
    # „É¢„É°„É≥„Çø„É†Áî®Ë®≠ÂÆö
    config = {
        "STRATEGY_TYPE": "MOMENTUM",
        "PRICE_MOMENTUM_PERIOD": 14,
        "MOMENTUM_THRESHOLD": 2.0,
        "MIN_MOMENTUM_STRENGTH": 0.6,
        "RSI_PERIOD": 14,
        "MACD_FAST": 12,
        "MACD_SLOW": 26,
        "MACD_SIGNAL": 9,
        "TAKE_PROFIT_MULTIPLIER": 2.5,
        "STOP_LOSS_MULTIPLIER": 1.5,
        "MAX_POSITIONS": 6,
        "POSITION_SIZE_PCT": 15.0
    }
    
    # 1Âπ¥Èñì„Éê„ÉÉ„ÇØ„ÉÜ„Çπ„Éà„Ç∑„Çπ„ÉÜ„É†‰ΩúÊàê
    logger.info("üìä „É¢„É°„É≥„Çø„É†„Éê„ÉÉ„ÇØ„ÉÜ„Çπ„Éà„Ç∑„Çπ„ÉÜ„É†‰ΩúÊàê‰∏≠...")
    annual_system = await WindowsUnifiedSystemFactory.create_annual_backtest_system(
        config, use_real_data=True
    )
    
    # „É¢„É°„É≥„Çø„É†„Ç∑„Çπ„ÉÜ„É†„Å´Â§âÊèõ
    momentum_system = MomentumBacktestSystem(
        config, annual_system.historical_data, annual_system.symbols,
        annual_system.start_date, annual_system.end_date
    )
    
    # „Éê„ÉÉ„ÇØ„ÉÜ„Çπ„ÉàÂÆüË°å
    logger.info("üöÄ „É¢„É°„É≥„Çø„É†„Éê„ÉÉ„ÇØ„ÉÜ„Çπ„ÉàÂÆüË°å‰∏≠...")
    results = await momentum_system.run_annual_comprehensive_backtest()
    
    # ÁµêÊûúË°®Á§∫
    print("\n" + "="*80)
    print("üöÄ „É¢„É°„É≥„Çø„É†Êà¶Áï• 1Âπ¥Èñì„Éê„ÉÉ„ÇØ„ÉÜ„Çπ„ÉàÂÆå‰∫Ü")
    print("üìä Ë™øÊüªÂ†±ÂëäÊõ∏Ê∫ñÊã†ÂÆüË£ÖÔºàÊúüÂæÖÂπ¥Âà©25-45%Ôºâ")
    print("="*80)
    
    perf = results['performance_metrics']
    print(f"\nüìà „Éë„Éï„Ç©„Éº„Éû„É≥„ÇπÁµêÊûú:")
    print(f"   Êà¶Áï•„Çø„Ç§„Éó: „É¢„É°„É≥„Çø„É†Ôºà„Éà„É¨„É≥„Éâ„Éï„Ç©„É≠„ÉºÔºâ")
    print(f"   Á∑èÂèñÂºïÊï∞: {perf['total_trades']}")
    print(f"   ÂãùÁéá: {perf['win_rate']:.1f}%")
    print(f"   Á∑è„É™„Çø„Éº„É≥: {perf['total_return']:+.1f}%")
    print(f"   ÊúÄÂ§ß„Éâ„É≠„Éº„ÉÄ„Ç¶„É≥: {perf['max_drawdown']:.1f}%")
    print(f"   „Ç∑„É£„Éº„Éó„É¨„Ç∑„Ç™: {perf['sharpe_ratio']:.2f}")
    print(f"   „Éó„É≠„Éï„Ç£„ÉÉ„Éà„Éï„Ç°„ÇØ„Çø„Éº: {perf['profit_factor']:.2f}")
    
    # ÁõÆÊ®ôÈÅîÊàêË©ï‰æ°
    target_monthly = 10.0  # Êúà10%ÁõÆÊ®ô
    target_annual = target_monthly * 12  # Âπ¥120%
    achievement_rate = (perf['total_return'] / target_annual) * 100
    
    print(f"\nüéØ ÁõÆÊ®ôÈÅîÊàêÂ∫¶:")
    print(f"   Êúà10%ÁõÆÊ®ô (Âπ¥120%) vs ÂÆüÁ∏æÂπ¥{perf['total_return']:+.1f}%")
    print(f"   ÈÅîÊàêÁéá: {achievement_rate:.1f}%")
    
    if perf['total_return'] >= 25.0:
        print("‚úÖ Ë™øÊüªÂ†±ÂëäÊõ∏ÊúüÂæÖÂÄ§ÔºàÂπ¥25-45%ÔºâÈÅîÊàê")
    else:
        print("‚ùå Ë™øÊüªÂ†±ÂëäÊõ∏ÊúüÂæÖÂÄ§Êú™ÈÅîÊàê")
    
    # ÂÖ®Êà¶Áï•ÊØîËºÉ
    print(f"\nüìä Êà¶Áï•ÊØîËºÉ:")
    print(f"   „Ç∞„É™„ÉÉ„ÉâÂèñÂºï: +0.2% (ÂãùÁéá100%, ÂèñÂºï53)")
    print(f"   DCA Bot: +0.0% (ÂãùÁéá100%, ÂèñÂºï1)")
    print(f"   „Ç¢„Éº„Éì„Éà„É©„Éº„Ç∏: -0.2% (ÂãùÁéá49.3%, ÂèñÂºï505)")
    print(f"   „É¢„É°„É≥„Çø„É†: {perf['total_return']:+.1f}% (ÂãùÁéá{perf['win_rate']:.1f}%, ÂèñÂºï{perf['total_trades']})")
    
    return results

async def main():
    """„É°„Ç§„É≥ÂÆüË°å"""
    await run_momentum_backtest()

if __name__ == "__main__":
    asyncio.run(main())